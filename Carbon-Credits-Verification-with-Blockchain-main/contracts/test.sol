// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;


import {VRFConsumerBaseV2Plus} from "@chainlink/contracts@1.4.0/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts@1.4.0/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";


contract VRFD20 is VRFConsumerBaseV2Plus {
    uint256 private constant ROLL_IN_PROGRESS = 42;

    // Your subscription ID.
    uint256 public s_subscriptionId;

    // Sepolia coordinator. For other networks,
    // see https://docs.chain.link/vrf/v2-5/supported-networks#configurations
    address public vrfCoordinator = 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/vrf/v2-5/supported-networks#configurations
    bytes32 public s_keyHash =
        0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;

    uint256[] public s_randomWords;


    uint32 public callbackGasLimit = 100000;

    // The default is 3, but you can set this higher.
    uint16 public requestConfirmations = 3;

    // For this example, retrieve 1 random value in one request.
    // Cannot exceed VRFCoordinatorV2_5.MAX_NUM_WORDS.
    uint32 public numWords = 1;


    constructor(uint256 subscriptionId) VRFConsumerBaseV2Plus(vrfCoordinator) {
        s_subscriptionId = subscriptionId;
    }

    function rollDice() public onlyOwner returns (uint256 requestId) {
        // Will revert if subscription is not set and funded.
        requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: s_keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    // Set nativePayment to true to pay for VRF requests with Sepolia ETH instead of LINK
                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
                )
            })
        );

    }

    function fulfillRandomWords(uint256,uint256[] calldata randomWords ) internal override {
        s_randomWords = randomWords;
    }

}

// import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";


// contract Counter is AutomationCompatibleInterface {
//     /**
//      * Public counter variable
//      */
//     uint256 public counter;

//     /**
//      * Use an interval in seconds and a timestamp to slow execution of Upkeep
//      */
//     uint256 public immutable interval;
//     uint256 public lastTimeStamp;

//     constructor(uint256 updateInterval) {
//         interval = updateInterval;
//         lastTimeStamp = block.timestamp;

//         counter = 0;
//     }

//     function checkUpkeep(
//         bytes calldata /* checkData */
//     )
//         external
//         view
//         override
//         returns (bool upkeepNeeded, bytes memory /* performData */)
//     {
//         upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
//         // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
//     }

//     function performUpkeep(bytes calldata /* performData */) external override {
//         if ((block.timestamp - lastTimeStamp) > interval) {
//             lastTimeStamp = block.timestamp;
//             counter = counter + 1;
//         }
//         // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
//     }
// }



////////alert upkeep contract

// import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";


// contract Alert is AutomationCompatibleInterface {
//     /**
//      * Public counter variable
//      */
//     uint256 public counter;
//     Lock public lock;
//     /**
//      * Use an interval in seconds and a timestamp to slow execution of Upkeep
//      */
//     uint256 public immutable interval;
//     uint256 public lastTimeStamp;

//     event Message(string);


//     event SendAlert(address addr, string message);

//     constructor(uint256 updateInterval) {
//         interval = updateInterval;
//         lastTimeStamp = block.timestamp;
//         counter = 0;
//     }

//     function deployLock() public {
//         lock = new Lock();
//         lock.newProject();
//         lock.newProp();
//     }
    
//     function returnDeposits() public {
//         lock.changeProjectState(lock.getProjectState(4));

//     }

//     receive() external payable {
//         require(address(lock) != address(0), "Lock contract not deployed yet."); 

//         (bool success, ) = address(lock).call{value: address(this).balance}(""); 
//         require(success, "Failed to send Ether to Lock.");

//     }

//     function checkUpkeep(
//         bytes calldata /* checkData */
//     )
//         external
//         view
//         override
//         returns (bool upkeepNeeded, bytes memory /* performData */)
//     {
//         upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
//         // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
//     }

//     function sendMessage(address recipientAddress, string memory message) public {
//         // Interface-style call to the recipient's function
//         (bool success, ) = recipientAddress.call(
//             abi.encodeWithSignature("receiveMessage(string)", message)
//         );
//         require(success, "Message delivery failed!");
//     }

//     function performUpkeep(bytes calldata /* performData */) external override {
//         if ((block.timestamp - lastTimeStamp) > interval) {
//             lastTimeStamp = block.timestamp;
//             counter = counter + 1;
//             // emit Message("Monitoring session reminder");
//             // emit Message("Deploy the Lock contract");
//             string memory message = string(abi.encodePacked("Monitoring # ", Strings.toString(counter)));
//             sendMessage(0x17491b6C551F5eF7A5C25c6b767fde1219C3aae5,message);
//         }
//         // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
//     }
// }
